% !TeX root = ../thesis.tex

\chapter{软件实现}

\section{Linux 实现}

Linux \cite{linux} 是世界上最著名的开源操作系统。Linux 是标准的宏内核，可以在其上运行多种应用。目前 Linux 已经支持在 RISC-V 硬件平台上运行，也能在 QEMU 模拟的 RISC-V 硬件环境上运行。为了支持用户态中断并对其性能进行更深入的分析，我们对 Linux 6.0 版本进行了修改。针对 Linux 的修改主要分为三个部分：

\begin{itemize}
    \item 添加 UINTC 驱动并让 Linux 识别 UINTC 的设备树信息
    \item 接收方陷入内核前的状态的保存与恢复
    \item 注册并实现系统调用
\end{itemize}

\subsection{UINTC 驱动支持}

\label{code:uintcpriv}
\begin{lstlisting}[style=CStyle]
    struct uintc_priv {
        struct cpumask lmask; // 位图记录已连接的 CPU
        void __iomem *regs;   // UINTC 在内核地址空间映射的起始地址
        resource_size_t size; // UINTC 地址范围大小
        u32 nr;               // UINTC 槽位数量
        void *mask;           // 位图记录已分配的槽位
        spinlock_t lock;      // 互斥锁
    };
\end{lstlisting}

驱动代码位于 drivers/irqchip/irq-riscv-uintc.c ，Linux 对 UINTC 进行的初始化过程如下：

\begin{itemize}
    \item 解析设备树获取外设对应的物理地址范围
    \item 初始化全局控制结构 \ref{code:uintcpriv} 并保存外设信息
    \item 调用 \mintinline[breaklines]{c}{void __iomem *ioremap(phys_addr_t addr, size_t size)} 完成内核物理地址到虚拟地址的映射，内核可以通过虚拟地址直接访问 UINTC 读写端口
    \item 初始化全局位图管理 UINTC 中已分配的槽位
\end{itemize}

\subsection{状态保存与恢复}

arch/riscv/kernel/entry.S 是 Linux 在 RISC-V 硬件平台上运行时的陷入入口，涉及上下文的保存与恢复、针对不同陷入原因跳转到对应的处理函数入口、针对不同系统调用号跳转到系统调用向量表对应的入口等。

Linux 中线程也被称为轻量级进程（LWP, Light-weight process）\cite{linuxbook}，如无特殊说明，描述中默认使用进程指代进程或线程。考虑到在某些负载环境下，接收方进程可能在不同核上迁移，需要对用户态的控制状态进行保存与恢复，主要对 \Rutvec 、\Ruscratch、\Ruepc 三个寄存器进行保存。此外还需要在陷入时将接收方状态的 Active 位置 0 确保当这个核运行其他进程时不会被中断。接收方被唤醒并准备在某个核上运行前，除了对上述三个寄存器进行恢复外，还需要设置 \Rsuirs 寄存器。

\subsection{进程管理}

在 arch/riscv/kernel/uintr.c 中添加用户态中断相关代码，主要涉及以下内容：

\begin{itemize}
    \item 控制结构定义和初始化：在进程控制块中维护发送方和接收方的状态
    \item 进程资源分配和回收：文件描述符，进程控制块内的状态，发送方状态表等
    \item 系统调用实现：在系统调用向量表中注册系统调用号，并通过 SYSCALL\_DEFINEx 宏声明并实现系统调用函数
\end{itemize}

\section{库函数实现}

为方便用户态程序使用系统调用接口，以库函数的形式对系统调用进一步封装，默认支持包括设置 U 态 CSR 、上下文保存与恢复以及读取并更新 UINTC 中的 Pending Requests 等功能：

\begin{lstlisting}[style=CStyle]
    #include "uintr.h"

    extern void __handler_entry(struct __uintr_frame* frame, void* handler) {
        uint64_t irqs = uipi_read();
        csr_clear(CSR_UIP, MIE_USIE);
        uint64_t (*__handler)(struct __uintr_frame * frame, uint64_t) = handler;
        irqs = __handler(frame, irqs);
        uipi_write(irqs);
    }
    static uint64_t __register_receiver(void* handler) {
        // 设置中断处理函数入口
        csr_write(CSR_UTVEC, uintrvec);
        csr_write(CSR_USCRATCH, handler);
        // 使能 U 态中断处理
        csr_set(CSR_USTATUS, USTATUS_UIE);
        csr_set(CSR_UIE, MIE_USIE);
        int ret = __syscall0(__NR_uintr_register_receiver);
        // 使能 UINTC 
        uipi_activate();
        return ret;
    }
    // 用户调用接口
    #define uintr_register_receiver(handler) __register_receiver(handler)
\end{lstlisting}

注意到上述代码并没将用户注册的函数直接赋值给 \Rutvec 寄存器，而是赋值给了 \Ruscratch ，这是因为在汇编代码中需要先将通用寄存器保存在栈上，然后才能开始执行用户注册的函数。
